# よろずデモ 開発・実装規約（抜粋）

このドキュメントは、`yorozu-demo` の既存コードを前提にした「読みやすさ重視」の実装規約です。  
すべてを網羅するものではなく、特に重要なポイントに絞って整理しています。

---

## 1. 全体方針

- **Next.js / TypeScript / App Router 前提**
  - `src/app` 配下の App Router 構成を前提とし、ページは `page.tsx`、レイアウトは `layout.tsx` を基本とします。
  - TypeScript は `strict: true` で動作しているため、**可能な限り `any` を避けて型を付ける**ことを優先します。
- **読みやすさ > 早さ・短さ**
  - 多少コード量が増えても、**意図が追いやすい実装**を優先します。
  - 一度に多くのことをしない・関数を小さく保つ・条件分岐を整理する、などを心がけます。
- **デモ用であることを意識**
  - 実運用向けの堅牢さより、「**ユーザーに構成と流れが伝わるか**」を重視します。

---

## 2. ディレクトリ構成の原則

- `src/app/`
  - ルーティングとページコンポーネントを置きます。
  - `src/app/yorozu-demo/` 以下に、本デモの画面群（`branch`, `hq`, `stories`, `input`, `components`, `context` など）がまとまっています。
  - 各画面は基本的に「**ページコンポーネント（状態＋組み立て）**」と「**プレゼンテーションコンポーネント**」に分割します。
- `src/lib/`
  - ドメイン型 (`types.ts`)、モックデータ (`mockData` 配下)、汎用的な関数 (`utils` 配下) を配置します。
  - **型とデータはここに集約**し、画面側ではそれを利用するだけにします。
- `src/styles/`
  - デモ固有のスタイル（`yorozu-demo.css` など）を配置します。
  - 汎用 CSS はここに追加し、ページ側には Tailwind クラスを中心に書きます。

---

## 3. TypeScript と型設計

- **ドメイン型は `src/lib/types.ts` に集約**
  - 相談カテゴリ・都道府県・ケース・成功事例など、**業務的な意味を持つ型はここで定義**します。
  - 画面側で同じ構造を再定義せず、既存の型を再利用します。
- **ユニオン型と `as const` を積極利用**
  - カテゴリやステータスなどは、文字列ユニオンとして表現し、`mockData` の配列から `as const` で型を導出するスタイルを踏襲します。
- **コンポーネントの Props は専用の型を定義**
  - `type XxxProps = { ... }` のように props 型を定義し、コンポーネント引数に適用します。
  - 状態のスナップショット（例: `CaseDraft`）は、**専用の型として export** し、複数箇所から再利用できるようにします。

---

## 4. React / Next.js コンポーネント設計

- **関数コンポーネント + Arrow Function**
  - すべての React コンポーネントは関数コンポーネントとし、`const Xxx = () => { ... }` を基本とします。
  - ページ (`page.tsx`) / レイアウト (`layout.tsx`) 以外のコンポーネントは **名前付き export** を使います。
- **クライアントコンポーネントの扱い**
  - フォーム・グラフ・インタラクションを含むものは `use client` を明示し、Hooks (`useState`, `useEffect`, `useMemo` など) を利用します。
  - 必要以上に `use client` を広げず、「入力・操作が必要な部分」に限定します。
- **コンテキストとカスタム Hook**
  - 全画面共通のデモ状態（相談件数など）は `DemoStateContext` のように **Context + Provider + `useXxx` Hook** のパターンで管理します。
  - `useDemoState` のように、Context が未定義の場合は `Error` を throw して早期に問題に気づけるようにします。

---

## 5. 状態管理とデータの扱い

- **ページで状態を持ち、コンポーネントへ渡す**
  - 画面単位の状態（選択された都道府県、年度、フィルタ条件など）はページコンポーネントで管理します。
  - フォームやカードなどの子コンポーネントには、**状態の値とコールバックだけを props で渡す**構成にします。
- **派生データは `useMemo` や純粋関数で**
  - KPI やチャート用データなど、計算コストやロジックがあるものは `useMemo` か `src/lib/utils` の純粋関数で計算します。
  - 例: `calcKpi.ts` のように、**UI から独立した計算ロジック**を分離します。
- **モックデータは読み取り専用**
  - `src/lib/mockData` 内のデータは基本的に不変として扱い、更新は Context が持つカウンタや派生データで表現します。

---

## 6. スタイリングと UI ルール

- **Tailwind クラス + 最小限のカスタム CSS**
  - レイアウト・余白・タイポグラフィは Tailwind クラスを優先し、カスタムクラスは `yorozu-card`, `yorozu-hero`, `yorozu-grid` など、**`yorozu-` プレフィックス付き**で定義します。
  - カスタムクラスの定義は `src/styles/yorozu-demo.css` にまとめます。
- **一貫した UI パターン**
  - カード (`yorozu-card`)、グリッド (`yorozu-grid`)、ヘッダ (`Header` コンポーネント) などのパターンを崩さず、**既存コンポーネントに寄せる**形で新規 UI を追加します。
  - フォームは `label` + `input/select/textarea` を基本とし、既存フォーム（`CaseForm`, `Plan0Form` など）の構成・クラス構成を参考に統一します。
- **アクセシビリティを意識**
  - クリック可能な要素には `button` / `a` を使い、`type="button"`/`type="submit"` を明示します。
  - 折りたたみなどの UI では `aria-expanded` などを付与し、既存のモバイル用 UI 実装に合わせます。

---

## 7. 命名とコードスタイル

- **命名規則**
  - コンポーネント・型・クラス: `PascalCase` (`BranchPage`, `KpiCard`, `DemoStateProvider` など)
  - 変数・関数: `camelCase` (`generateCaseId`, `handleSort`, `getTopCategories` など)
  - 状態セット関数: `setXxx`, `updateXxx`, `toggleXxx` のように意図が分かる動詞を使います。
- **インポートとパス**
  - ルート配下は `@/` エイリアスを使い、**長い相対パスは避ける**（`@/lib/...`, `@/app/yorozu-demo/components/...`）。
  - インポートの順序は「React/Next → 外部ライブラリ → アプリ内 (`@/`) → 相対パス」の流れを基本とします。
- **フォーマット**
  - 既存ファイルと同様に、ダブルクォート・セミコロンあり・末尾カンマありのスタイルに合わせます。
  - 自動整形ツール（Prettier など）に任せられる部分は、極力ツールの出力に従います。

---

## 8. 画面追加時のチェックリスト（簡易）

新しい画面や機能を追加する際は、次の点を満たしているか簡単に確認してください。

1. ルーティング  
   - `src/app/yorozu-demo/` 以下に適切なフォルダを切り、`page.tsx` を配置しているか。
2. 型・データ  
   - 新しいドメイン情報がある場合、`src/lib/types.ts` や `src/lib/mockData` に型・データを追加しているか。
3. 状態とロジック  
   - ページで状態を持ち、子コンポーネントには props として渡す構成になっているか。
4. UI とスタイル  
   - 既存のカード・グリッド・フォームのパターンに合わせたスタイルになっているか。
5. 可読性  
   - 変数名・関数名から役割が読み取れ、条件分岐や計算ロジックが追いやすいか。

上記を満たしていれば、既存のコードベースと自然につながる形で、読みやすい実装になっているはずです。

